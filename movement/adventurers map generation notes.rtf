{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf390
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww12080\viewh8800\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 Adventurers notes\
\
Movement on a map:\
\
CreateMoveField(hero_position, hero_MP) \{ // takes the hero's position, move points (based on speed)\
	// If hero has fly, teleport, etc. apply their particular effects downstream (e.g., don't factor in rubble or mud, increase move field for teleportation etc.). This is applied each time - sometimes heroes have a temporary movement bonus (potion of flight, character flip effect etc.)\
	// on the map, first generate a square with sides equal to (hero_MP*2 + 1)\
	// cut out the corners based on distance formula\
	// remove squares that are walls and non-traversable obstacles\
	// for each remaining square, calculate its score and the shortest path. Store shortest path in a separate object, display the score in one corner of the square. Squares that can't be reached (not enough movement points, blocked off by walls, etc.) should also be removed.\
	// draw green outline around outside of the move field, based on adjacent squares with score<=mp and score>mp\
\
\
\
a* equation: start with shortest path, if that path is equal to the distance (following the x + 1/2y OR y + 1/2x distance formula [whichever is lower, and always round down]), return that path, and you're done. If path is greater than distance, check each path and something something. Google A * algorithm.\
\
}